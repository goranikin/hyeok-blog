---
globs: *.ts,*.tsx,*.js,*.jsx,*.json
description: Code quality, formatting, and linting standards using Biome
---

# Code Quality & Formatting

This project uses Biome for code formatting and linting. Follow these standards for consistent, high-quality code.

## Biome Configuration

### Formatting Rules
- Use double quotes for strings (configured in [biome.json](mdc:biome.json))
- Use space indentation (2 spaces)
- Enable automatic import organization
- Example configuration: `"quoteStyle": "double"` and `"indentStyle": "space"`

### Linting Rules
- Enable recommended rules for best practices
- Use TypeScript strict mode
- Apply consistent naming conventions
- Example: `"rules": { "recommended": true }`

## TypeScript Standards

### Type Definitions
- Use explicit type annotations for function parameters and return types
- Define interfaces for complex data structures
- Use union types for component variants
- Example: `export type Post = { permalink: string; slug: string; title: string; ... }`

### Import/Export Patterns
- Use named exports for utilities and components
- Use default exports for page components
- Group imports logically: React/Next.js, third-party, local
- Example: `import { cn } from "@/utils/cn"`

### Function Definitions
- Use arrow functions for component definitions
- Use function declarations for utility functions
- Apply proper parameter typing
- Example: `const getPostBySlug = ({ slug, category }: { slug: string; category: string }) => { ... }`

## React Patterns

### Component Structure
- Use functional components with TypeScript
- Define proper prop interfaces
- Use "use client" directive only when necessary
- Example: `export default function PostList({ posts, basePath }: PostListProps) { ... }`

### Hook Usage
- Use React hooks properly with dependency arrays
- Implement proper state initialization
- Use custom hooks for complex logic
- Example: `useEffect(() => { ... }, [pathname])`

### Event Handling
- Use proper TypeScript typing for event handlers
- Implement proper event delegation
- Use callback functions for state updates
- Example: `onClick={() => setSelectedCategory(item)}`

## Code Organization

### File Structure
- Use descriptive filenames
- Group related functionality in directories
- Use index files for clean imports
- Example: [src/components/ui/](mdc:src/components/ui/) for UI components

### Component Organization
- Keep components focused and single-purpose
- Use composition over inheritance
- Implement proper separation of concerns
- Example: Separate navigation logic from UI components

### Utility Functions
- Create reusable utility functions
- Use proper TypeScript typing
- Implement error handling
- Example: [src/utils/cn.ts](mdc:src/utils/cn.ts) for class name utilities

## Performance Standards

### Code Splitting
- Use dynamic imports for heavy components
- Implement proper loading states
- Use React.lazy() for route-based splitting
- Example: `const Component = React.lazy(() => import('./Component'))`

### Memory Management
- Avoid memory leaks in useEffect
- Use proper cleanup functions
- Implement proper dependency arrays
- Example: `useEffect(() => { return () => { cleanup() } }, [deps])`

### Bundle Optimization
- Use tree shaking effectively
- Avoid unnecessary re-renders
- Implement proper memoization
- Example: `React.memo()` for expensive components

## Error Handling

### Type Safety
- Use proper TypeScript strict mode
- Implement runtime type checking where needed
- Use proper error boundaries
- Example: `Post | undefined` return types

### Validation
- Use Zod for schema validation
- Implement proper form validation
- Use proper error messages
- Example: Schema validation in [velite.config.js](mdc:velite.config.js)

## Documentation Standards

### Code Comments
- Use JSDoc for function documentation
- Comment complex logic
- Use descriptive variable names
- Example: `// MDX 코드 문자열을 React 컴포넌트로 변환하는 함수`

### Type Documentation
- Use descriptive type names
- Document complex type relationships
- Use proper generics
- Example: `interface MDXProps { code: string; components?: Record<string, React.ComponentType> }`

## Testing Standards

### Component Testing
- Write tests for complex components
- Test user interactions
- Use proper testing utilities
- Example: Test navigation state changes

### Integration Testing
- Test API routes
- Test content processing
- Test build processes
- Example: Test Velite content generation

## Build and Deployment

### Build Optimization
- Use proper build configurations
- Implement proper asset optimization
- Use proper environment variables
- Example: `output: "standalone"` in [next.config.mjs](mdc:next.config.mjs)

### Performance Monitoring
- Use proper performance metrics
- Implement proper error tracking
- Use proper analytics
- Example: Monitor build times and bundle sizes